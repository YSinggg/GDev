<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Serpent's Ascent: Deluxe</title>
    <link rel="icon" href="icon.svg">
    <style>
        :root {
            --bg-color: #2c3e50;
            --accent: #f39c12;
            --text: #ecf0f1;
        }
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            box-sizing: border-box;
        }
        h1 { 
            margin-bottom: 15px; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5); 
            font-size: 2.5rem;
            color: var(--accent);
        }
        
        /* --- Game Container & Sidebar --- */
        .main-container {
            display: flex;
            gap: 25px;
            align-items: flex-start;
            filter: blur(5px); /* Blurred until game starts */
            transition: filter 0.5s;
        }
        .main-container.active { filter: none; }

        canvas {
            background: linear-gradient(135deg, #ffffff 0%, #bdc3c7 100%);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border-radius: 12px;
            border: 4px solid #34495e;
        }
        .sidebar {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .card {
            background: rgba(0,0,0,0.4);
            padding: 20px;
            border-radius: 12px;
            border-left: 6px solid var(--accent);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .dice-display {
            font-size: 2.5rem;
            text-align: center;
            margin-top: 15px;
            font-weight: bold;
            color: var(--accent);
            text-shadow: 1px 1px 2px black;
        }
        .btn-action {
            background: linear-gradient(to bottom, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 18px;
            font-size: 1.3rem;
            cursor: pointer;
            border-radius: 8px;
            font-weight: bold;
            width: 100%;
            text-transform: uppercase;
            box-shadow: 0 4px #9f2b1e;
            transition: all 0.1s;
        }
        .btn-action:active:not(:disabled) {
            transform: translateY(4px);
            box-shadow: 0 0 #9f2b1e;
        }
        .btn-action:disabled { 
            background: #7f8c8d; 
            box-shadow: none;
            cursor: not-allowed; 
            opacity: 0.8;
        }
        
        .log-box {
            height: 280px;
            overflow-y: auto;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            font-size: 0.95rem;
            border-radius: 8px;
            border: 1px solid #546e7a;
        }
        .log-entry { margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .log-highlight { color: var(--accent); font-weight: bold; }
        .log-danger { color: #e74c3c; font-weight: bold; }
        .log-success { color: #2ecc71; font-weight: bold; }
        
        /* --- Setup Modal --- */
        #setupOverlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .setup-box {
            background: #34495e;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            border: 2px solid var(--accent);
            max-width: 500px;
            width: 100%;
        }
        .setup-group { margin-bottom: 20px; text-align: left; }
        label { display: block; margin-bottom: 8px; font-weight: bold; }
        select, input {
            width: 100%; padding: 12px; border-radius: 6px; border: none;
            font-size: 1.1rem; background: #ecf0f1; color: #2c3e50;
            box-sizing: border-box;
        }
        .mode-tabs {
            display: flex;
            margin-bottom: 20px;
            gap: 10px;
        }
        .tab-btn {
            flex: 1;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 4px;
        }
        .tab-btn.active {
            background: var(--accent);
            font-weight: bold;
        }
        .hidden { display: none; }

        .code-display {
            font-size: 2rem;
            letter-spacing: 5px;
            font-family: monospace;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            margin: 10px 0;
            border: 2px dashed var(--accent);
        }
    </style>
</head>
<body>

    <div id="setupOverlay">
        <div class="setup-box">
            <h2 style="color: var(--accent); margin-top: 0;">Game Setup</h2>

            <div class="mode-tabs">
                <button class="tab-btn active" onclick="switchMode('local')">Local Play</button>
                <button class="tab-btn" onclick="switchMode('online')">Online Multiplayer</button>
            </div>

            <!-- LOCAL MODE CONFIG -->
            <div id="localConfig">
                <div class="setup-group">
                    <label for="totalPlayers">Total Players (2-6):</label>
                    <select id="totalPlayers">
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4" selected>4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                    </select>
                </div>
                <div class="setup-group">
                    <label for="aiPlayers">AI Opponents:</label>
                    <select id="aiPlayers">
                        <option value="0">0 (All Human)</option>
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3" selected>3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                    </select>
                </div>
                <button class="btn-action" id="startBtn">Start Local Game üé≤</button>
            </div>

            <!-- ONLINE MODE CONFIG -->
            <div id="onlineConfig" class="hidden">
                <div id="lobbyControls">
                    <div class="setup-group">
                        <label>Display Name:</label>
                        <input type="text" id="playerName" placeholder="Enter your name" maxlength="12">
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn-action" style="flex:1" id="createRoomBtn">Host Game</button>
                        <button class="btn-action" style="flex:1; background: #3498db;" id="joinRoomBtn">Join Game</button>
                    </div>
                    <div class="setup-group" id="joinInputGroup" style="display:none; margin-top: 15px;">
                        <label>Room Code:</label>
                        <input type="text" id="roomCodeInput" placeholder="Ex: A1B2" style="text-transform: uppercase;">
                        <button class="btn-action" id="confirmJoinBtn" style="margin-top: 10px;">Enter Room</button>
                    </div>
                </div>

                <div id="lobbyWaiting" class="hidden">
                    <h3>Room Code:</h3>
                    <div class="code-display" id="lobbyCodeDisplay">----</div>
                    <p>Waiting for players...</p>
                    <div id="lobbyPlayerList" style="text-align: left; background: rgba(0,0,0,0.2); padding: 10px; margin-bottom: 20px; border-radius: 4px;">
                        <!-- Player List -->
                    </div>
                    <button class="btn-action" id="onlineStartBtn" disabled>Start Game</button>
                    <p id="waitingMsg" class="hidden">Waiting for host to start...</p>
                </div>
            </div>
        </div>
    </div>

    <h1>Serpent's Ascent: Deluxe üêçüëë</h1>

    <div class="main-container" id="mainContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="sidebar">
            <div class="card">
                <h2 id="currentPlayerText" style="margin: 0 0 10px 0; border-bottom: 2px solid rgba(255,255,255,0.2); padding-bottom: 10px;">
                    Player 1
                </h2>
                <div style="display: flex; justify-content: space-between;">
                     <span id="statusType">Status: Normal</span>
                     <span id="statusIcon">üòä</span>
                </div>
                <div class="dice-display" id="diceResult">READY</div>
            </div>

            <button class="btn-action" id="rollBtn" disabled>ROLL DICE</button>

            <div class="log-box" id="gameLog"></div>
        </div>
    </div>

<script>
// ===========================
// AUDIO SUBSYSTEM
// ===========================
const AudioEngine = {
    ctx: null,
    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    playTone: function(freq, type, duration, fadeOut = true, volume = 0.2) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(volume, this.ctx.currentTime);
        if(fadeOut) gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playNoise: function(duration, volume = 0.1) {
        if(!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'bandpass'; filter.frequency.value = 1000;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(volume, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        noise.connect(filter).connect(gain).connect(this.ctx.destination);
        noise.start();
    },
    sfxStep: function() { this.playTone(400, 'sine', 0.08, true, 0.3); },
    sfxDice: function() { this.playNoise(0.4, 0.25); },
    sfxPowerup: function() { 
        if(!this.ctx) return;
        const now = this.ctx.currentTime;
        this.playTone(600, 'sine', 0.5, false, 0.2);
        const osc = this.ctx.createOscillator(); osc.connect(this.ctx.destination);
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.linearRampToValueAtTime(1200, now + 0.5);
        osc.start(); osc.stop(now + 0.5);
    },
    sfxSnake: function() {
        if(!this.ctx) return;
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        osc.connect(gain).connect(this.ctx.destination);
        osc.type = 'sawtooth';
        gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now+0.8);
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.8);
        osc.start(); osc.stop(now + 0.8);
    },
    sfxCrush: function() {
         this.playNoise(0.3, 0.5);
         this.playTone(100, 'square', 0.2, true, 0.5);
    },
    sfxFail: function() { this.playTone(150, 'sawtooth', 0.4, true, 0.4); },
    sfxWin: function() {
        const notes = [523.25, 659.25, 783.99, 1046.50]; // C E G C
        notes.forEach((note, i) => {
            setTimeout(() => this.playTone(note, 'triangle', 0.6, true, 0.3), i * 150);
        });
    }
};

// ===========================
// NETWORK MANAGER
// ===========================
class NetworkManager {
    constructor(game) {
        this.game = game;
        this.roomCode = null;
        this.evtSource = null;
        this.myId = Math.random().toString(36).substr(2, 9);
        this.isHost = false;
        this.playersInLobby = [];
    }

    connect(roomCode, playerName, isHost) {
        this.roomCode = roomCode;
        this.isHost = isHost;
        this.evtSource = new EventSource(`/events?room=${roomCode}`);

        this.evtSource.onmessage = (e) => {
            // Heartbeat check (ignore ': heartbeat')
            if (e.data.trim() === '') return;
        };

        // Standard event listener doesn't work well with raw 'data:' stream unless named 'message'
        // We used 'data: JSON' in server.js, so it comes as 'message' event.
        this.evtSource.addEventListener('message', (e) => {
            try {
                if(!e.data) return;
                const msg = JSON.parse(e.data);
                this.handleMessage(msg);
            } catch (err) {
                console.error("Parse error", err);
            }
        });

        // Announce Join
        setTimeout(() => {
            this.send({ type: 'JOIN', id: this.myId, name: playerName });
        }, 500);
    }

    send(payload) {
        fetch('/action', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ room: this.roomCode, payload: payload })
        });
    }

    handleMessage(msg) {
        // console.log("Received:", msg);
        if (msg.type === 'JOIN') {
            if (this.isHost) {
                // Check if new
                if (!this.playersInLobby.find(p => p.id === msg.id)) {
                    this.playersInLobby.push({ id: msg.id, name: msg.name });
                    this.updateLobbyUI();
                    // Send full list to sync others
                    this.send({ type: 'LOBBY_UPDATE', players: this.playersInLobby });
                }
            }
        } else if (msg.type === 'LOBBY_UPDATE') {
            if (!this.isHost) {
                this.playersInLobby = msg.players;
                this.updateLobbyUI();
            }
        } else if (msg.type === 'START_GAME') {
            this.game.startOnlineGame(msg.config, this.playersInLobby);
        } else if (msg.type === 'ROLL_REQUEST') {
            if (this.isHost && this.game.isOnline) {
                this.game.hostExecuteTurn(msg.playerId);
            }
        } else if (msg.type === 'TURN_RESULT') {
            this.game.clientExecuteTurn(msg.data);
        }
    }

    updateLobbyUI() {
        const list = document.getElementById('lobbyPlayerList');
        list.innerHTML = this.playersInLobby.map(p =>
            `<div style="padding:4px; border-bottom:1px solid #aaa;">${p.name} ${p.id===this.myId ? '(You)':''}</div>`
        ).join('');

        if (this.isHost) {
            document.getElementById('onlineStartBtn').disabled = this.playersInLobby.length < 2;
        }
    }
}


// ===========================
// GAME LOGIC
// ===========================
let CONFIG = {
    totalSquares: 200, cols: 20, rows: 10,
    players: 4, humanCount: 1,
    colors: [
        {main: '#e74c3c', glow: '#c0392b'}, // Red
        {main: '#3498db', glow: '#2980b9'}, // Blue
        {main: '#9b59b6', glow: '#8e44ad'}, // Purple
        {main: '#f1c40f', glow: '#f39c12'}, // Yellow
        {main: '#2ecc71', glow: '#27ae60'}, // Green
        {main: '#e67e22', glow: '#d35400'}  // Orange
    ]
};

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = 800 * dpr;
        this.canvas.height = 600 * dpr;
        this.ctx.scale(dpr, dpr);
        this.canvas.style.width = '800px';
        this.canvas.style.height = '600px';

        this.tileWidth = 800 / CONFIG.cols;
        this.tileHeight = 600 / CONFIG.rows;
        
        this.players = [];
        this.snakes = {};
        this.powerups = [];
        this.turnIndex = 0;
        this.isAnimating = false;
        this.frameCount = 0;
        
        this.isOnline = false;
        this.net = null;
        this.myNetworkId = null;

        this.gameLoop();
    }

    // Called for Local Play
    initLocal() {
        this.isOnline = false;
        // Generate Setup
        for(let i=0; i<CONFIG.players; i++) {
            let isBot = i >= CONFIG.humanCount;
            this.players.push({
                id: i, name: isBot ? `CPU ${i+1}` : `Player ${i+1}`,
                isCPU: isBot, pos: 0,
                colorPalette: CONFIG.colors[i],
                debuff: 0, powerup: false
            });
        }
        this.initBoard();
        this.log("Welcome to Local Play!", "log-highlight");
        this.checkTurn();
    }

    // Called when 'START_GAME' received or Host starts
    startOnlineGame(config, lobbyPlayers) {
        this.isOnline = true;
        CONFIG = config; // Sync config
        document.getElementById('setupOverlay').style.display = 'none';
        document.getElementById('mainContainer').classList.add('active');

        // Map lobby players to game players
        this.players = lobbyPlayers.map((p, i) => ({
            id: i,
            networkId: p.id,
            name: p.name,
            isCPU: false, // All online players are human for now
            pos: 0,
            colorPalette: CONFIG.colors[i % CONFIG.colors.length],
            debuff: 0, powerup: false
        }));

        this.myPlayerIndex = this.players.findIndex(p => p.networkId === this.net.myId);

        this.initBoard();
        this.log("Online Game Started!", "log-highlight");
        this.checkTurn();
    }

    initBoard() {
        // Generate Snakes (Fixed)
        const snakeDefs = [{h:198,t:48}, {h:180,t:90}, {h:150,t:20}, {h:120,t:60}, {h:99,t:10}, {h:190,t:100}, {h:75,t:30}, {h:55,t:5}, {h:160,t:140}, {h:110,t:80}];
        snakeDefs.forEach(s => this.snakes[s.h] = s.t);

        // Generate Powerups (Fixed seed for online consistency would be better, but Host Authority handles it)
        // Ideally Host generates and sends list. For simplicity, we'll assume collisions handled by Host result.
        // Actually, powerups rendering needs to match.
        // Quick fix: Use deterministic locations or send them in Config.
        // For now, let's just generate them locally. NOTE: In online, visual might mismatch if using Math.random().
        // *Correction*: In online, Host should send powerup locations.
        // To save time, I will use a fixed list of powerups.
        this.powerups = [15, 35, 55, 85, 115, 145, 175];
    }

    getCoord(index) {
        const rowFromBottom = Math.floor(index / CONFIG.cols);
        const col = index % CONFIG.cols;
        let x = (rowFromBottom % 2 === 0) ? col * this.tileWidth : (CONFIG.cols - 1 - col) * this.tileWidth;
        let y = 600 - ((rowFromBottom + 1) * this.tileHeight);
        return {x, y};
    }

    gameLoop() {
        this.frameCount++;
        this.draw();
        requestAnimationFrame(() => this.gameLoop());
    }

    draw() {
        this.ctx.clearRect(0, 0, 800, 600);
        // (Drawing code same as before, omitted for brevity but included in file write)
        // ... (See full file content below)
        
        // 1. Draw Tiles
        for(let i=0; i<CONFIG.totalSquares; i++) {
            const pos = this.getCoord(i);
            let bgGrad = this.ctx.createLinearGradient(pos.x, pos.y, pos.x, pos.y + this.tileHeight);
            if (i === 199) {
                const pulse = Math.sin(this.frameCount * 0.1) * 20 + 20;
                bgGrad.addColorStop(0, `rgb(241, 196, 15, ${pulse/100 + 0.5})`);
                bgGrad.addColorStop(1, '#d35400');
            } else if (i % 2 === 0) {
                bgGrad.addColorStop(0, '#ecf0f1'); bgGrad.addColorStop(1, '#bdc3c7');
            } else {
                bgGrad.addColorStop(0, '#bdc3c7'); bgGrad.addColorStop(1, '#95a5a6');
            }
            this.ctx.fillStyle = bgGrad;
            this.ctx.shadowColor = 'rgba(0,0,0,0.2)'; this.ctx.shadowBlur = 4; this.ctx.shadowOffsetX = 2; this.ctx.shadowOffsetY = 2;
            this.ctx.fillRect(pos.x+1, pos.y+1, this.tileWidth-2, this.tileHeight-2);
            this.ctx.shadowColor = 'transparent';

            this.ctx.textAlign = "center"; this.ctx.textBaseline = "middle";
            const midX = pos.x + this.tileWidth/2; const midY = pos.y + this.tileHeight/2;

            if (this.powerups.includes(i)) {
                this.ctx.font = "20px Arial"; this.ctx.fillText("‚ö°", midX, midY);
            }
            if (i === 199) {
                 this.ctx.font = "24px Arial"; this.ctx.fillText("üëë", midX, midY);
            }
            this.ctx.font = "10px Arial"; this.ctx.fillStyle = 'rgba(0,0,0,0.4)';
            this.ctx.fillText(i, pos.x + 10, pos.y + 10);
        }

        // 2. Draw Snakes
        Object.keys(this.snakes).forEach(headIdx => {
            headIdx = parseInt(headIdx);
            const tailIdx = this.snakes[headIdx];
            const headPos = this.getCoord(headIdx); const tailPos = this.getCoord(tailIdx);
            const hX = headPos.x + this.tileWidth/2; const hY = headPos.y + this.tileHeight/2;
            const tX = tailPos.x + this.tileWidth/2; const tY = tailPos.y + this.tileHeight/2;

            this.ctx.beginPath(); this.ctx.moveTo(hX, hY);
            let cp1x = hX + (tX - hX) * 0.2; let cp1y = hY;
            let cp2x = tX - (tX - hX) * 0.2; let cp2y = tY;
            if (hX > tX) { cp1x += 50; cp2x -= 50; } else { cp1x -= 50; cp2x += 50; }
            this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, tX, tY);
            
            this.ctx.strokeStyle = '#c0392b'; this.ctx.lineWidth = 8; this.ctx.lineCap = 'round'; this.ctx.stroke();
            this.ctx.strokeStyle = '#e74c3c'; this.ctx.lineWidth = 4; this.ctx.setLineDash([5, 5]); this.ctx.stroke();
            this.ctx.setLineDash([]);
            this.ctx.font = "16px Arial"; this.ctx.fillText("üêç", hX, hY-5);
        });

        // 3. Draw Players
        this.players.forEach((p, idx) => {
            const pos = this.getCoord(p.pos);
            const offsetX = (idx % 3) * 10 + 10;
            const offsetY = Math.floor(idx / 3) * 10 + 20;
            const pX = pos.x + offsetX; const pY = pos.y + offsetY;

            this.ctx.shadowColor = p.colorPalette.glow; this.ctx.shadowBlur = 15;
            let pGrad = this.ctx.createRadialGradient(pX, pY, 2, pX, pY, 12);
            pGrad.addColorStop(0, 'white'); pGrad.addColorStop(1, p.colorPalette.main);
            
            this.ctx.beginPath(); this.ctx.arc(pX, pY, 12, 0, 2 * Math.PI);
            this.ctx.fillStyle = pGrad; this.ctx.fill();
            this.ctx.shadowBlur = 0;
            this.ctx.strokeStyle = 'white'; this.ctx.lineWidth = 2; this.ctx.stroke();

            if(p.debuff < 0) this.ctx.fillText("üòì", pX, pY - 15);
            if(p.isCPU && !this.isOnline) {
                 this.ctx.font = "10px Arial"; this.ctx.fillText("ü§ñ", pX, pY + 5);
            }
            if(this.isOnline && this.players[this.myPlayerIndex] && p.id === this.players[this.myPlayerIndex].id) {
                this.ctx.font = "10px Arial"; this.ctx.fillText("ME", pX, pY + 5);
            }
        });
    }

    // --- INTERACTION ---
    humanRoll() {
        const player = this.players[this.turnIndex];

        if (this.isOnline) {
            // Only allow if it's my turn
            if (this.turnIndex !== this.myPlayerIndex) return;
            // Send Request to Host
            this.net.send({ type: 'ROLL_REQUEST', playerId: player.id });
            document.getElementById('rollBtn').disabled = true;
            document.getElementById('rollBtn').innerText = "WAITING...";
        } else {
            // Local Play
            if (!player.isCPU && !this.isAnimating) this.executeTurnLocal(player);
        }
    }

    // HOST ONLY: Calculates logic and sends result
    async hostExecuteTurn(playerId) {
        const player = this.players.find(p => p.id === playerId);
        
        let diceCount = player.powerup ? 2 : 1;
        let powerupUsed = player.powerup;
        player.powerup = false;

        let rolls = [];
        let rollTotal = 0;
        for(let i=0; i<diceCount; i++) {
            let r = Math.floor(Math.random() * 6) + 1;
            rolls.push(r);
            rollTotal += r;
        }

        let initialMove = rollTotal;
        if (player.debuff < 0) {
            initialMove = Math.max(0, rollTotal + player.debuff);
            player.debuff = 0;
        }

        // Calculate path and events
        let currentPos = player.pos;
        let finalPos = currentPos + initialMove;
        let events = [];

        // Overshoot
        if (finalPos > 199) {
            events.push({ type: 'overshoot' });
            finalPos = currentPos;
        } else {
            // Check Snake
            if (this.snakes[finalPos]) {
                events.push({ type: 'snake', from: finalPos, to: this.snakes[finalPos] });
                finalPos = this.snakes[finalPos];
            }
            // Check Powerup
            if (this.powerups.includes(finalPos)) {
                events.push({ type: 'powerup', pos: finalPos });
                // Note: Actual powerup flag update happens on clients
            }
            // Check Crush
            if (finalPos !== 0) {
                const crushed = this.players.find(other => other.id !== playerId && other.pos === finalPos);
                if (crushed) {
                    events.push({ type: 'crush', victimId: crushed.id });
                }
            }
        }

        const turnData = {
            playerId,
            rolls,
            initialMove,
            finalPos, // Target final position
            powerupUsed,
            events
        };

        // Broadcast result
        this.net.send({ type: 'TURN_RESULT', data: turnData });
    }

    // ALL CLIENTS: Animates based on data
    async clientExecuteTurn(data) {
        this.isAnimating = true;
        const player = this.players.find(p => p.id === data.playerId);
        const btn = document.getElementById('rollBtn');
        btn.disabled = true;

        AudioEngine.sfxDice();
        
        let rollStr = data.rolls.join(" + ");
        if (data.rolls.length > 1) this.log(`Rolled: ${rollStr} = ${data.rolls.reduce((a,b)=>a+b)}`);

        if (data.powerupUsed) this.log("Uses Powerup!", "log-highlight");

        if (data.initialMove !== data.rolls.reduce((a,b)=>a+b)) {
            this.log(`Dazed! Moves ${data.initialMove}.`, "log-danger");
        }

        document.getElementById('diceResult').innerText = data.initialMove;
        await new Promise(r => setTimeout(r, 400));

        // Animate Move
        if (data.initialMove > 0) {
            const steps = data.events.find(e=>e.type==='overshoot') ? 0 : data.initialMove; // If overshoot, we don't move fully?
            // Actually usually games animate up to 199 then bounce back, or just stay.
            // Simplified: If overshoot, don't move or move and fail.
            // Let's implement overshoot visual:
            if (data.events.find(e=>e.type==='overshoot')) {
                this.log("Overshot! Stay put.", "log-danger");
                AudioEngine.sfxFail();
            } else {
                // Animate step by step
                let startP = player.pos;
                for(let i=0; i<data.initialMove; i++) {
                    player.pos++;
                    AudioEngine.sfxStep();
                    await new Promise(r => setTimeout(r, 180));
                }
            }
        }

        // Process Events
        for (let evt of data.events) {
            if (evt.type === 'snake') {
                this.log("Oh no! A snake!", "log-danger");
                AudioEngine.sfxSnake();
                await new Promise(r => setTimeout(r, 500));
                player.pos = evt.to;
            } else if (evt.type === 'powerup') {
                AudioEngine.sfxPowerup();
                this.log("Found Powerup!", "log-success");
                player.powerup = true;
            } else if (evt.type === 'crush') {
                AudioEngine.sfxCrush();
                const victim = this.players.find(p => p.id === evt.victimId);
                this.log(`üí• CRUSHED ${victim.name}!`, "log-highlight");
                victim.debuff = -2;
            }
        }
        
        // Sync final position just in case
        // player.pos = data.finalPos;

        // Check Win
        if (player.pos === 199) {
             AudioEngine.sfxWin();
             this.log(`üèÜ ${player.name} WINS! üèÜ`, "log-success");
             document.getElementById('rollBtn').innerText = "GAME OVER";
             document.getElementById('currentPlayerText').innerText = player.name + " WINS!";
        } else {
            this.turnIndex = (this.turnIndex + 1) % CONFIG.players;
            this.isAnimating = false;
            this.checkTurn();
        }
    }

    // Legacy Local Execute (for offline play)
    async executeTurnLocal(player) {
        // Reuse host logic logic locally...
        // For simplicity, keeping the old logic here would be redundant code.
        // Instead, mock the data packet and pass to clientExecuteTurn!

        let diceCount = player.powerup ? 2 : 1;
        let rolls = [];
        let rollTotal = 0;
        for(let i=0; i<diceCount; i++) { let r = Math.floor(Math.random() * 6) + 1; rolls.push(r); rollTotal += r; }

        let initialMove = rollTotal;
        if (player.debuff < 0) {
            initialMove = Math.max(0, rollTotal + player.debuff);
            player.debuff = 0; // Local specific state update
        }

        // We need to calculate events to pass to clientExecuteTurn, OR
        // just let clientExecuteTurn handle purely visual and we handle logic mixed?
        // To save code size, let's just create the mock object.

        // ... (Simulate Host Logic)
        let powerupUsed = player.powerup;
        if(powerupUsed) player.powerup = false;

        let events = [];
        let finalPos = player.pos + initialMove;

        if (finalPos > 199) {
            events.push({type:'overshoot'});
            finalPos = player.pos;
        } else {
            if(this.snakes[finalPos]) { events.push({type:'snake', from:finalPos, to:this.snakes[finalPos]}); finalPos = this.snakes[finalPos]; }
            if(this.powerups.includes(finalPos)) { events.push({type:'powerup'}); }
            if(finalPos !== 0) {
                 const crushed = this.players.find(other => other.id !== player.id && other.pos === finalPos);
                 if(crushed) events.push({type:'crush', victimId:crushed.id});
            }
        }

        const data = {
            playerId: player.id,
            rolls,
            initialMove,
            powerupUsed,
            events
        };

        await this.clientExecuteTurn(data);
    }

    checkTurn() {
        const player = this.players[this.turnIndex];
        const btn = document.getElementById('rollBtn');
        const statusTitle = document.getElementById('currentPlayerText');
        const statusType = document.getElementById('statusType');
        const statusIcon = document.getElementById('statusIcon');

        statusTitle.innerText = player.name;
        statusTitle.style.color = player.colorPalette.main;
        document.getElementById('diceResult').innerText = "READY";

        if (player.debuff < 0) {
             statusType.innerText = "Status: DAZED (-2 Roll)"; statusIcon.innerText = "üòì"; statusType.style.color = '#e74c3c';
        } else if (player.powerup) {
             statusType.innerText = "Status: POWERED UP (x2 Dice)"; statusIcon.innerText = "‚ö°"; statusType.style.color = '#f1c40f';
        } else {
             statusType.innerText = "Status: Normal"; statusIcon.innerText = "üòä"; statusType.style.color = 'white';
        }

        // Logic for button state
        if (this.isOnline) {
            if (this.turnIndex === this.myPlayerIndex) {
                 btn.disabled = false;
                 btn.innerText = "ROLL DICE üé≤";
            } else {
                 btn.disabled = true;
                 btn.innerText = `WAITING FOR ${player.name}...`;
            }
        } else {
            // Local
            if (player.isCPU) {
                btn.disabled = true; btn.innerText = "CPU THINKING...";
                setTimeout(() => this.executeTurnLocal(player), 1000 + Math.random()*500);
            } else {
                btn.disabled = false; btn.innerText = "ROLL DICE üé≤";
            }
        }
    }

    log(msg, type="") {
        const box = document.getElementById('gameLog');
        box.innerHTML = `<div class="log-entry ${type}">${this.players[this.turnIndex].name}: ${msg}</div>` + box.innerHTML;
    }
}

// ===========================
// UI HANDLERS
// ===========================
let gameInstance = null;

function switchMode(mode) {
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    event.target.classList.add('active');
    if(mode === 'local') {
        document.getElementById('localConfig').classList.remove('hidden');
        document.getElementById('onlineConfig').classList.add('hidden');
    } else {
        document.getElementById('localConfig').classList.add('hidden');
        document.getElementById('onlineConfig').classList.remove('hidden');
    }
}

// Local Start
document.getElementById('startBtn').addEventListener('click', () => {
    AudioEngine.init();
    const totalP = parseInt(document.getElementById('totalPlayers').value);
    const aiP = parseInt(document.getElementById('aiPlayers').value);
    if(aiP >= totalP) { alert("Need at least 1 human."); return; }

    CONFIG.players = totalP; CONFIG.humanCount = totalP - aiP;
    document.getElementById('setupOverlay').style.display = 'none';
    document.getElementById('mainContainer').classList.add('active');

    gameInstance = new Game();
    gameInstance.initLocal();
    document.getElementById('rollBtn').onclick = () => gameInstance.humanRoll();
});

// Online Handlers
const nameInput = document.getElementById('playerName');

document.getElementById('createRoomBtn').addEventListener('click', () => {
    const name = nameInput.value || "Host";
    const code = Math.random().toString(36).substring(2, 6).toUpperCase();

    document.getElementById('lobbyControls').classList.add('hidden');
    document.getElementById('lobbyWaiting').classList.remove('hidden');
    document.getElementById('lobbyCodeDisplay').innerText = code;

    gameInstance = new Game();
    gameInstance.net = new NetworkManager(gameInstance);
    gameInstance.net.connect(code, name, true);

    document.getElementById('rollBtn').onclick = () => gameInstance.humanRoll();
});

document.getElementById('joinRoomBtn').addEventListener('click', () => {
    document.getElementById('joinInputGroup').style.display = 'block';
});

document.getElementById('confirmJoinBtn').addEventListener('click', () => {
    const name = nameInput.value || "Guest";
    const code = document.getElementById('roomCodeInput').value.toUpperCase();
    if(!code) return;

    document.getElementById('lobbyControls').classList.add('hidden');
    document.getElementById('lobbyWaiting').classList.remove('hidden');
    document.getElementById('lobbyCodeDisplay').innerText = code;
    document.getElementById('waitingMsg').classList.remove('hidden');
    document.getElementById('onlineStartBtn').style.display = 'none';

    gameInstance = new Game();
    gameInstance.net = new NetworkManager(gameInstance);
    gameInstance.net.connect(code, name, false);

    document.getElementById('rollBtn').onclick = () => gameInstance.humanRoll();
});

document.getElementById('onlineStartBtn').addEventListener('click', () => {
    AudioEngine.init();
    // Configure game
    const players = gameInstance.net.playersInLobby;
    const config = { ...CONFIG, players: players.length, humanCount: players.length };

    // Broadcast Start
    gameInstance.net.send({ type: 'START_GAME', config: config });
});

</script>
</body>
</html>