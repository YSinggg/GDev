<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Serpent's Ascent: Deluxe</title>
    <link rel="icon" href="icon.svg">
    <style>
        :root {
            --bg-color: #2c3e50;
            --accent: #f39c12;
            --text: #ecf0f1;
        }
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            box-sizing: border-box;
        }
        h1 { 
            margin-bottom: 15px; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5); 
            font-size: 2.5rem;
            color: var(--accent);
        }
        
        /* --- Game Container & Sidebar --- */
        .main-container {
            display: flex;
            gap: 25px;
            align-items: flex-start;
            filter: blur(5px); /* Blurred until game starts */
            transition: filter 0.5s;
        }
        .main-container.active { filter: none; }

        canvas {
            background: linear-gradient(135deg, #ffffff 0%, #bdc3c7 100%);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border-radius: 12px;
            border: 4px solid #34495e;
        }
        .sidebar {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .card {
            background: rgba(0,0,0,0.4);
            padding: 20px;
            border-radius: 12px;
            border-left: 6px solid var(--accent);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .dice-display {
            font-size: 2.5rem;
            text-align: center;
            margin-top: 15px;
            font-weight: bold;
            color: var(--accent);
            text-shadow: 1px 1px 2px black;
        }
        .btn-action {
            background: linear-gradient(to bottom, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 18px;
            font-size: 1.3rem;
            cursor: pointer;
            border-radius: 8px;
            font-weight: bold;
            width: 100%;
            text-transform: uppercase;
            box-shadow: 0 4px #9f2b1e;
            transition: all 0.1s;
        }
        .btn-action:active:not(:disabled) {
            transform: translateY(4px);
            box-shadow: 0 0 #9f2b1e;
        }
        .btn-action:disabled { 
            background: #7f8c8d; 
            box-shadow: none;
            cursor: not-allowed; 
            opacity: 0.8;
        }
        
        .log-box {
            height: 280px;
            overflow-y: auto;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            font-size: 0.95rem;
            border-radius: 8px;
            border: 1px solid #546e7a;
        }
        .log-entry { margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .log-highlight { color: var(--accent); font-weight: bold; }
        .log-danger { color: #e74c3c; font-weight: bold; }
        .log-success { color: #2ecc71; font-weight: bold; }
        
        /* --- Setup Modal --- */
        #setupOverlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .setup-box {
            background: #34495e;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            border: 2px solid var(--accent);
        }
        .setup-group { margin-bottom: 20px; text-align: left; }
        label { display: block; margin-bottom: 8px; font-weight: bold; }
        select {
            width: 100%; padding: 12px; border-radius: 6px; border: none;
            font-size: 1.1rem; background: #ecf0f1; color: #2c3e50;
        }
    </style>
</head>
<body>

    <div id="setupOverlay">
        <div class="setup-box">
            <h2 style="color: var(--accent); margin-top: 0;">Game Setup</h2>
            <div class="setup-group">
                <label for="totalPlayers">Total Players (2-6):</label>
                <select id="totalPlayers">
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4" selected>4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                </select>
            </div>
            <div class="setup-group">
                <label for="aiPlayers">AI Opponents:</label>
                <select id="aiPlayers">
                    <option value="0">0 (All Human)</option>
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3" selected>3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                </select>
            </div>
            <button class="btn-action" id="startBtn">Start Game üé≤</button>

            <div style="margin-top: 20px; border-top: 1px solid #546e7a; padding-top: 20px;">
                <h3 style="color: var(--accent); margin: 0 0 10px 0;">Online Multiplayer</h3>
                <div style="display: flex; gap: 10px;">
                    <button class="btn-action" id="hostBtn" style="background: #27ae60; font-size: 1rem; padding: 12px;">Host Game</button>
                    <button class="btn-action" id="joinBtn" style="background: #2980b9; font-size: 1rem; padding: 12px;">Join Game</button>
                </div>
                <div id="joinArea" style="display: none; margin-top: 10px;">
                    <input type="text" id="roomInput" placeholder="Enter Room Code" style="padding: 10px; width: 60%; border-radius: 4px; border: none;">
                    <button class="btn-action" id="connectBtn" style="background: #2980b9; font-size: 0.9rem; padding: 10px; width: 30%;">Connect</button>
                </div>
                <div id="lobbyArea" style="display: none; margin-top: 10px; color: #ecf0f1;">
                    <p>Room Code: <span id="roomCodeDisplay" style="color: var(--accent); font-weight: bold; font-size: 1.5rem;"></span></p>
                    <p id="lobbyStatus">Waiting for players...</p>
                    <button class="btn-action" id="multiStartBtn" style="background: #f39c12; margin-top: 10px;">Start Multiplayer</button>
                </div>
            </div>
        </div>
    </div>

    <h1>Serpent's Ascent: Deluxe üêçüëë</h1>

    <div class="main-container" id="mainContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="sidebar">
            <div class="card">
                <h2 id="currentPlayerText" style="margin: 0 0 10px 0; border-bottom: 2px solid rgba(255,255,255,0.2); padding-bottom: 10px;">
                    Player 1
                </h2>
                <div style="display: flex; justify-content: space-between;">
                     <span id="statusType">Status: Normal</span>
                     <span id="statusIcon">üòä</span>
                </div>
                <div class="dice-display" id="diceResult">READY</div>
            </div>

            <button class="btn-action" id="rollBtn" disabled>ROLL DICE</button>

            <div class="log-box" id="gameLog"></div>
        </div>
    </div>

<script>
// ===========================
// AUDIO SUBSYSTEM (Web Audio API)
// ===========================
const AudioEngine = {
    ctx: null,
    init: function() {
        // Initialize on first user interaction to bypass autoplay policies
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    
    // Helper to create standard beep/tone
    playTone: function(freq, type, duration, fadeOut = true, volume = 0.2) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.type = type; // 'sine', 'square', 'sawtooth', 'triangle'
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(volume, this.ctx.currentTime);
        if(fadeOut) gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },

    // Helper for noise (snakes/dice)
    playNoise: function(duration, volume = 0.1) {
        if(!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 1000;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(volume, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        noise.connect(filter).connect(gain).connect(this.ctx.destination);
        noise.start();
    },

    // --- SFX Definitions ---
    sfxStep: function() { this.playTone(400, 'sine', 0.08, true, 0.3); },
    sfxDice: function() { this.playNoise(0.4, 0.25); },
    sfxPowerup: function() { 
        if(!this.ctx) return;
        const now = this.ctx.currentTime;
        this.playTone(600, 'sine', 0.5, false, 0.2);
        // Pitch bend up
        const osc = this.ctx.createOscillator(); osc.connect(this.ctx.destination);
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.linearRampToValueAtTime(1200, now + 0.5);
        osc.start(); osc.stop(now + 0.5);
    },
    sfxSnake: function() {
        if(!this.ctx) return;
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        osc.connect(gain).connect(this.ctx.destination);
        osc.type = 'sawtooth';
        gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now+0.8);
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.8);
        osc.start(); osc.stop(now + 0.8);
    },
    sfxCrush: function() {
         this.playNoise(0.3, 0.5);
         this.playTone(100, 'square', 0.2, true, 0.5);
    },
    sfxFail: function() { this.playTone(150, 'sawtooth', 0.4, true, 0.4); },
    sfxWin: function() {
        const notes = [523.25, 659.25, 783.99, 1046.50]; // C E G C
        notes.forEach((note, i) => {
            setTimeout(() => this.playTone(note, 'triangle', 0.6, true, 0.3), i * 150);
        });
    }
};

// ===========================
// GAME LOGIC & VISUALS
// ===========================
let CONFIG = {
    totalSquares: 200, cols: 20, rows: 10,
    players: 4, humanCount: 1,
    colors: [
        {main: '#e74c3c', glow: '#c0392b'}, // Red
        {main: '#3498db', glow: '#2980b9'}, // Blue
        {main: '#9b59b6', glow: '#8e44ad'}, // Purple
        {main: '#f1c40f', glow: '#f39c12'}, // Yellow
        {main: '#2ecc71', glow: '#27ae60'}, // Green
        {main: '#e67e22', glow: '#d35400'}  // Orange
    ]
};

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        // Enable high DPI rendering
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = 800 * dpr;
        this.canvas.height = 600 * dpr;
        this.ctx.scale(dpr, dpr);
        this.canvas.style.width = '800px';
        this.canvas.style.height = '600px';

        this.tileWidth = 800 / CONFIG.cols;
        this.tileHeight = 600 / CONFIG.rows;
        
        this.players = [];
        this.snakes = {};
        this.powerups = [];
        this.turnIndex = 0;
        this.isAnimating = false;
        this.frameCount = 0; // For pulsing animations
        
        // Multiplayer flags
        this.isMultiplayer = false;
        this.isHost = false;
        this.roomId = null;
        this.myPlayerId = 0;

        this.init();
        this.gameLoop(); // Start rendering loop
    }

    initMultiplayer(isHost, roomId, playerId) {
        this.isMultiplayer = true;
        this.isHost = isHost;
        this.roomId = roomId;
        this.myPlayerId = playerId;

        // Refresh UI state now that we know we are multiplayer
        this.checkTurn();

        if (isHost) {
            // Host broadcasts start game to sync powerups
            // A small delay to ensure everyone is listening
            setTimeout(() => {
                netManager.sendSignal('START_GAME', {
                    players: CONFIG.players,
                    humanCount: CONFIG.humanCount,
                    powerups: this.powerups
                });
            }, 500);
        }
    }

    init() {
        // 1. Init Players based on Setup configs
        for(let i=0; i<CONFIG.players; i++) {
            let isBot = i >= CONFIG.humanCount;
            this.players.push({
                id: i, name: isBot ? `CPU ${i+1}` : `Player ${i+1}`,
                isCPU: isBot, pos: 0,
                colorPalette: CONFIG.colors[i],
                debuff: 0, powerup: false
            });
        }

        // 2. Generate Snakes 
        const snakeDefs = [{h:198,t:48}, {h:180,t:90}, {h:150,t:20}, {h:120,t:60}, {h:99,t:10}, {h:190,t:100}, {h:75,t:30}, {h:55,t:5}, {h:160,t:140}, {h:110,t:80}];
        snakeDefs.forEach(s => this.snakes[s.h] = s.t);

        // 3. Generate Powerups
        for(let i=0; i<7; i++) {
            let pos;
            do { pos = Math.floor(Math.random() * 190) + 5; } 
            while (this.snakes[pos] || pos === 0 || this.powerups.includes(pos));
            this.powerups.push(pos);
        }

        this.log("Welcome to Serpent's Ascent!", "log-highlight");
        this.checkTurn();
    }

    getCoord(index) {
        const rowFromBottom = Math.floor(index / CONFIG.cols);
        const col = index % CONFIG.cols;
        let x = (rowFromBottom % 2 === 0) ? col * this.tileWidth : (CONFIG.cols - 1 - col) * this.tileWidth;
        let y = 600 - ((rowFromBottom + 1) * this.tileHeight);
        return {x, y};
    }

    // --- THE RENDER LOOP ---
    gameLoop() {
        this.frameCount++;
        this.draw();
        requestAnimationFrame(() => this.gameLoop());
    }

    draw() {
        this.ctx.clearRect(0, 0, 800, 600);
        
        // 1. Draw Tiles (Enhanced)
        for(let i=0; i<CONFIG.totalSquares; i++) {
            const pos = this.getCoord(i);
            
            // Gradient Base
            let bgGrad = this.ctx.createLinearGradient(pos.x, pos.y, pos.x, pos.y + this.tileHeight);
            if (i === 199) { // Win tile pulsing
                const pulse = Math.sin(this.frameCount * 0.1) * 20 + 20;
                bgGrad.addColorStop(0, `rgb(241, 196, 15, ${pulse/100 + 0.5})`);
                bgGrad.addColorStop(1, '#d35400');
            } else if (i % 2 === 0) {
                bgGrad.addColorStop(0, '#ecf0f1'); bgGrad.addColorStop(1, '#bdc3c7');
            } else {
                bgGrad.addColorStop(0, '#bdc3c7'); bgGrad.addColorStop(1, '#95a5a6');
            }
            
            this.ctx.fillStyle = bgGrad;
            // Bevel effect
            this.ctx.shadowColor = 'rgba(0,0,0,0.2)';
            this.ctx.shadowBlur = 4;
            this.ctx.shadowOffsetX = 2;
            this.ctx.shadowOffsetY = 2;
            this.ctx.fillRect(pos.x+1, pos.y+1, this.tileWidth-2, this.tileHeight-2);
            this.ctx.shadowColor = 'transparent'; // Reset shadow

            // Tile Icons
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            const midX = pos.x + this.tileWidth/2;
            const midY = pos.y + this.tileHeight/2;

            if (this.powerups.includes(i)) {
                this.ctx.font = "20px Arial"; this.ctx.fillText("‚ö°", midX, midY);
            }
            if (i === 199) {
                 this.ctx.font = "24px Arial"; this.ctx.fillText("üëë", midX, midY);
            }
            
            // Numbers
            this.ctx.font = "10px Arial";
            this.ctx.fillStyle = 'rgba(0,0,0,0.4)';
            this.ctx.fillText(i, pos.x + 10, pos.y + 10);
        }

        // 2. Draw Snakes (Curved Bezier)
        Object.keys(this.snakes).forEach(headIdx => {
            headIdx = parseInt(headIdx);
            const tailIdx = this.snakes[headIdx];
            const headPos = this.getCoord(headIdx);
            const tailPos = this.getCoord(tailIdx);
            
            const hX = headPos.x + this.tileWidth/2; const hY = headPos.y + this.tileHeight/2;
            const tX = tailPos.x + this.tileWidth/2; const tY = tailPos.y + this.tileHeight/2;

            this.ctx.beginPath();
            this.ctx.moveTo(hX, hY);
            // Bezier control points for curve
            let cp1x = hX + (tX - hX) * 0.2; let cp1y = hY;
            let cp2x = tX - (tX - hX) * 0.2; let cp2y = tY;
            // Flip curves based on direction to look more natural
            if (hX > tX) { cp1x += 50; cp2x -= 50; } else { cp1x -= 50; cp2x += 50; }

            this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, tX, tY);
            
            // Snake styling
            this.ctx.strokeStyle = '#c0392b';
            this.ctx.lineWidth = 8;
            this.ctx.lineCap = 'round';
            this.ctx.stroke();
            // Inner pattern line
            this.ctx.strokeStyle = '#e74c3c';
            this.ctx.lineWidth = 4;
            this.ctx.setLineDash([5, 5]);
            this.ctx.stroke();
            this.ctx.setLineDash([]); // Reset

            // Head Icon
            this.ctx.font = "16px Arial"; this.ctx.fillText("üêç", hX, hY-5);
        });

        // 3. Draw Players (Glowing Orbs)
        this.players.forEach((p, idx) => {
            const pos = this.getCoord(p.pos);
            // Stagger positions
            const offsetX = (idx % 3) * 10 + 10;
            const offsetY = Math.floor(idx / 3) * 10 + 20;
            const pX = pos.x + offsetX; const pY = pos.y + offsetY;

            // Glow effect
            this.ctx.shadowColor = p.colorPalette.glow;
            this.ctx.shadowBlur = 15;
            
            // Main body gradient
            let pGrad = this.ctx.createRadialGradient(pX, pY, 2, pX, pY, 12);
            pGrad.addColorStop(0, 'white');
            pGrad.addColorStop(1, p.colorPalette.main);
            
            this.ctx.beginPath();
            this.ctx.arc(pX, pY, 12, 0, 2 * Math.PI);
            this.ctx.fillStyle = pGrad;
            this.ctx.fill();
            this.ctx.shadowBlur = 0; // Reset glow

            // Border
            this.ctx.strokeStyle = 'white'; this.ctx.lineWidth = 2; this.ctx.stroke();

            // Status Icons
            if(p.debuff < 0) this.ctx.fillText("üòì", pX, pY - 15);
            if(p.isCPU) {
                 this.ctx.font = "10px Arial"; this.ctx.fillText("ü§ñ", pX, pY + 5);
            }
        });
    }

    // --- GAMEPLAY LOGIC ---
    async humanRoll() {
        const player = this.players[this.turnIndex];
        if (!player.isCPU && !this.isAnimating) {
            if (this.isMultiplayer) {
                // If it is my turn, I can roll
                if (this.turnIndex === this.myPlayerId) {
                    if (this.isHost) {
                         // Host Logic: Calculate and Broadcast
                         this.executeTurn(player, true);
                    } else {
                         // Client Logic: Request Host to Roll
                         netManager.sendSignal('REQUEST_ROLL', { playerId: this.myPlayerId });
                         document.getElementById('rollBtn').disabled = true;
                         document.getElementById('rollBtn').innerText = "WAITING...";
                    }
                }
            } else {
                this.executeTurn(player);
            }
        }
    }

    // Only Host calls this when receiving REQUEST_ROLL
    // Or Client calls this when receiving TURN_UPDATE
    async handleRemoteTurn(data) {
        if (this.isMultiplayer) {
             // If I am the one who triggered this turn (e.g. Host processing local turn),
             // I might have already started animation? No, let's keep it sync.

             // Host Logic: I already calculated everything and sent it.
             // Wait, if Host calls executeTurn(broadcast=true), it broadcasts THEN animates.
             // If Peer receives TURN_UPDATE, they just animate.

             if (this.isHost) return; // Host ignores its own broadcasts usually, or we can unify.

             // Peer Logic: Apply the data
             const player = this.players[data.playerId];
             this.turnIndex = data.playerId; // Sync turn just in case

             this.isAnimating = true;
             document.getElementById('rollBtn').disabled = true;

             // 1. Show Dice Result
             AudioEngine.sfxDice();
             document.getElementById('diceResult').innerText = data.finalMove;

             if (data.wasPowerup) {
                 player.powerup = false;
                 this.log("Uses Powerup!", "log-highlight");
             }
             if (data.wasDazed) {
                 this.log(`Dazed! Rolled ${data.rawRoll} but moves ${data.finalMove}.`, "log-danger");
                 player.debuff = 0;
             } else {
                 // Basic log
                 this.log(`Rolled: ${data.finalMove}`);
             }

             await new Promise(r => setTimeout(r, 400));

             // 2. Animate Move
             if (data.finalMove > 0) await this.animateMove(player, data.finalMove);

             // 3. Tile Events (Simulated visually, state is authoritative from server?)
             // Actually, Host just sent the result. Peer should update local state to match.
             // "checkTileEvents" updates position. We should rely on Host's data for final position?
             // But for visual effects (snake sound, etc) we want to run the checker.
             await this.checkTileEvents(player);

             // 4. Check Win
             if (player.pos === 199) {
                 AudioEngine.sfxWin();
                 this.log(`üèÜ ${player.name} WINS! üèÜ`, "log-success");
                 document.getElementById('rollBtn').innerText = "GAME OVER";
                 document.getElementById('currentPlayerText').innerText = player.name + " WINS!";
             } else {
                 this.turnIndex = (this.turnIndex + 1) % CONFIG.players;
                 this.isAnimating = false;
                 this.checkTurn();
             }
        }
    }

    checkTurn() {
        const player = this.players[this.turnIndex];
        const btn = document.getElementById('rollBtn');
        const statusTitle = document.getElementById('currentPlayerText');
        const statusType = document.getElementById('statusType');
        const statusIcon = document.getElementById('statusIcon');
        
        statusTitle.innerText = player.name;
        statusTitle.style.color = player.colorPalette.main;
        document.getElementById('diceResult').innerText = "READY";

        // Logic to disable controls if Multiplayer and not my turn
        let isMyTurn = true;
        if (this.isMultiplayer) {
            isMyTurn = (this.turnIndex === this.myPlayerId);
            // If I am Host, I also handle CPU turns?
            // If it is CPU turn, Host should execute it automatically.
            // Peer should just wait.
            if (player.isCPU && !this.isHost) isMyTurn = false;
        }

        if (player.debuff < 0) {
             statusType.innerText = "Status: DAZED (-2 Roll)"; statusIcon.innerText = "üòì"; statusType.style.color = '#e74c3c';
        } else if (player.powerup) {
             statusType.innerText = "Status: POWERED UP (x2 Dice)"; statusIcon.innerText = "‚ö°"; statusType.style.color = '#f1c40f';
        } else {
             statusType.innerText = "Status: Normal"; statusIcon.innerText = "üòä"; statusType.style.color = 'white';
        }

        if (player.isCPU) {
            btn.disabled = true; btn.innerText = "CPU THINKING...";
            // Only Host runs CPU logic
            if (!this.isMultiplayer || (this.isMultiplayer && this.isHost)) {
                setTimeout(() => this.executeTurn(player, this.isMultiplayer), 1000 + Math.random()*500);
            }
        } else {
            if (isMyTurn) {
                btn.disabled = false; btn.innerText = "ROLL DICE üé≤";
            } else {
                btn.disabled = true; btn.innerText = `WAITING FOR ${player.name}...`;
            }
        }
    }

    // Added broadcast param
    async executeTurn(player, broadcast = false) {
        // If Host in MP receiving a Request, or Host running CPU turn
        this.isAnimating = true;
        document.getElementById('rollBtn').disabled = true;
        
        AudioEngine.sfxDice(); // SFX
        let diceCount = player.powerup ? 2 : 1;
        let wasPowerup = player.powerup; // Capture state before reset
        if(player.powerup) { player.powerup = false; this.log("Uses Powerup!", "log-highlight"); }

        let rollTotal = 0; let rollStr = "";
        for(let i=0; i<diceCount; i++) {
            let r = Math.floor(Math.random() * 6) + 1; rollTotal += r;
            rollStr += (i>0?" + ":"") + r;
        }
        
        let finalMove = rollTotal;
        let wasDazed = false;
        if (player.debuff < 0) {
            wasDazed = true;
            finalMove = Math.max(0, rollTotal + player.debuff);
            this.log(`Dazed! Rolled ${rollTotal} but moves ${finalMove}.`, "log-danger");
            player.debuff = 0;
        } else {
             if(diceCount>1) this.log(`Rolled: ${rollStr} = ${rollTotal}`);
        }

        // Broadcast immediately if Host
        if (broadcast && this.isHost) {
             netManager.sendSignal('TURN_UPDATE', {
                 playerId: player.id,
                 rawRoll: rollTotal,
                 finalMove: finalMove,
                 wasPowerup: wasPowerup,
                 wasDazed: wasDazed
             });
        }

        document.getElementById('diceResult').innerText = finalMove;
        await new Promise(r => setTimeout(r, 400)); // Pause to see dice

        if (finalMove > 0) await this.animateMove(player, finalMove);
        
        await this.checkTileEvents(player);

        if (player.pos === 199) {
             AudioEngine.sfxWin(); // SFX
             this.log(`üèÜ ${player.name} WINS! üèÜ`, "log-success");
             document.getElementById('rollBtn').innerText = "GAME OVER";
             document.getElementById('currentPlayerText').innerText = player.name + " WINS!";
        } else {
            this.turnIndex = (this.turnIndex + 1) % CONFIG.players;
            this.isAnimating = false;
            this.checkTurn();
        }
    }

    async animateMove(player, steps) {
        for(let i=0; i<steps; i++) {
            // Overshoot Check
            if (player.pos + (steps - i) > 199) {
                this.log("Overshot! Needs exact roll.", "log-danger");
                AudioEngine.sfxFail(); // SFX
                // Screen shake
                this.ctx.save(); this.ctx.translate(Math.random()*10-5, Math.random()*10-5);
                await new Promise(r => setTimeout(r, 200));
                this.ctx.restore();
                return;
            }
            player.pos++;
            AudioEngine.sfxStep(); // SFX
            await new Promise(r => setTimeout(r, player.isCPU ? 100 : 180)); 
        }
    }

    async checkTileEvents(player) {
        // Snake
        if (this.snakes[player.pos]) {
            this.log("Oh no! A snake!", "log-danger");
            AudioEngine.sfxSnake(); // SFX
            await new Promise(r => setTimeout(r, 500));
            player.pos = this.snakes[player.pos];
        }
        // Powerup
        if (this.powerups.includes(player.pos)) {
            AudioEngine.sfxPowerup(); // SFX
            this.log("Found a Powerup! Next roll x2.", "log-success");
            player.powerup = true;
        }
        // Collision (Crush)
        if (player.pos !== 0) {
            this.players.forEach(other => {
                if (other.id !== player.id && other.pos === player.pos) {
                    AudioEngine.sfxCrush(); // SFX
                    this.log(`üí• CRUSHED ${other.name}!`, "log-highlight");
                    other.debuff = -2;
                    // Visual Flash
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    this.ctx.fillRect(0,0,800,600);
                }
            });
        }
    }

    log(msg, type="") {
        const box = document.getElementById('gameLog');
        box.innerHTML = `<div class="log-entry ${type}">${this.players[this.turnIndex].name}: ${msg}</div>` + box.innerHTML;
    }
}

// ===========================
// SETUP & INITIALIZATION
// ===========================
const startBtn = document.getElementById('startBtn');
const setupOverlay = document.getElementById('setupOverlay');
const mainContainer = document.getElementById('mainContainer');
let gameInstance;

startBtn.addEventListener('click', () => {
    // Initialize Audio first thing on user click
    AudioEngine.init();

    // Read configs
    const totalP = parseInt(document.getElementById('totalPlayers').value);
    const aiP = parseInt(document.getElementById('aiPlayers').value);

    if(aiP >= totalP) {
        alert("Error: Cannot have all players be AI. At least one human needed.");
        return;
    }

    CONFIG.players = totalP;
    CONFIG.humanCount = totalP - aiP;

    // Hide setup, show game
    setupOverlay.style.display = 'none';
    mainContainer.classList.add('active');

    // Start Game
    gameInstance = new Game();
    document.getElementById('rollBtn').addEventListener('click', () => gameInstance.humanRoll());
});

// Multiplayer UI Handlers
const hostBtn = document.getElementById('hostBtn');
const joinBtn = document.getElementById('joinBtn');
const joinArea = document.getElementById('joinArea');
const connectBtn = document.getElementById('connectBtn');
const lobbyArea = document.getElementById('lobbyArea');
const roomCodeDisplay = document.getElementById('roomCodeDisplay');
const multiStartBtn = document.getElementById('multiStartBtn');

hostBtn.addEventListener('click', async () => {
    AudioEngine.init();
    hostBtn.disabled = true;
    const roomId = await netManager.createRoom();
    if(roomId) {
        joinBtn.style.display = 'none';
        hostBtn.style.display = 'none';
        lobbyArea.style.display = 'block';
        roomCodeDisplay.innerText = roomId;
    }
});

joinBtn.addEventListener('click', () => {
    AudioEngine.init();
    joinArea.style.display = 'block';
    hostBtn.style.display = 'none';
    joinBtn.style.display = 'none';
});

connectBtn.addEventListener('click', async () => {
    const roomId = document.getElementById('roomInput').value.trim().toUpperCase();
    if(!roomId) return;

    connectBtn.disabled = true;
    const success = await netManager.joinRoom(roomId);
    if(success) {
        joinArea.style.display = 'none';
        lobbyArea.style.display = 'block';
        roomCodeDisplay.innerText = roomId;
        multiStartBtn.style.display = 'none'; // Only host can start
        document.getElementById('lobbyStatus').innerText = "Connected! Waiting for Host...";
    } else {
        connectBtn.disabled = false;
    }
});

multiStartBtn.addEventListener('click', () => {
    // Read configs for Multiplayer (Host decides)
    const totalP = parseInt(document.getElementById('totalPlayers').value);
    const aiP = parseInt(document.getElementById('aiPlayers').value);

    CONFIG.players = totalP;
    // Ensure humanCount matches at least 2 in multiplayer if defaults are used
    // Ideally, we should track connected players.
    // For now, if AI settings would make P2 a Bot, we override it if we are in multiplayer
    // Assuming at least 2 humans in multiplayer.
    let calculatedHumans = totalP - aiP;
    if (calculatedHumans < 2) calculatedHumans = 2; // Force at least 2 humans for MP

    CONFIG.humanCount = calculatedHumans;

    setupOverlay.style.display = 'none';
    mainContainer.classList.add('active');

    gameInstance = new Game();
    gameInstance.initMultiplayer(true, netManager.roomId, 0);
    document.getElementById('rollBtn').addEventListener('click', () => gameInstance.humanRoll());

    // Listen for peer requests
    netManager.eventSource.addEventListener('message', (e) => {
         const msg = JSON.parse(e.data);
         if (msg.event === 'REQUEST_ROLL' && gameInstance.isHost) {
             const player = gameInstance.players[msg.data.playerId];
             if (gameInstance.turnIndex === msg.data.playerId) {
                 gameInstance.executeTurn(player, true);
             }
         }
    });
});

// Pre-validation for setup UI
document.getElementById('totalPlayers').addEventListener('change', (e) => {
    const total = parseInt(e.target.value);
    const aiSelect = document.getElementById('aiPlayers');
    // Ensure AI count doesn't exceed Total-1
    Array.from(aiSelect.options).forEach(opt => {
        opt.disabled = parseInt(opt.value) >= total;
    });
    if(parseInt(aiSelect.value) >= total) {
        aiSelect.value = total - 1;
    }
});

// ===========================
// NETWORKING
// ===========================
class NetworkManager {
    constructor() {
        this.roomId = null;
        this.playerId = null;
        this.isHost = false;
        this.eventSource = null;
        // Point to local server. In a real deployment, this should be the server's address.
        this.serverUrl = 'http://localhost:3000';
    }

    async createRoom() {
        try {
            const res = await fetch(`${this.serverUrl}/api/create`, { method: 'POST' });
            const data = await res.json();
            this.roomId = data.roomId;
            this.isHost = true;
            this.playerId = 0; // Host is always 0
            this.connectSSE();
            return this.roomId;
        } catch (e) {
            console.error("Create Room Error:", e);
            alert("Failed to connect to server.");
        }
    }

    async joinRoom(roomId) {
        try {
            const res = await fetch(`${this.serverUrl}/api/join`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ roomId })
            });
            const data = await res.json();
            if (data.success) {
                this.roomId = roomId;
                this.isHost = false;
                this.playerId = data.playerId;
                this.connectSSE();
                return true;
            } else {
                alert(data.error || "Failed to join.");
                return false;
            }
        } catch (e) {
            console.error("Join Room Error:", e);
            alert("Failed to connect to server.");
            return false;
        }
    }

    connectSSE() {
        if (this.eventSource) this.eventSource.close();
        this.eventSource = new EventSource(`${this.serverUrl}/events?roomId=${this.roomId}`);

        this.eventSource.onerror = (e) => console.error("SSE Error", e);

        this.eventSource.onmessage = (e) => {
            const msg = JSON.parse(e.data);
            this.handleEvent(msg);
        };
    }

    handleEvent(msg) {
        // If we receive START_GAME, we might not have gameInstance yet if we are Peer in Lobby
        if (msg.event === 'START_GAME' && !gameInstance && !this.isHost) {
             CONFIG.players = msg.data.players;
             CONFIG.humanCount = msg.data.humanCount;
             setupOverlay.style.display = 'none';
             mainContainer.classList.add('active');
             gameInstance = new Game();
             gameInstance.initMultiplayer(false, this.roomId, this.playerId);
             gameInstance.powerups = msg.data.powerups;
             gameInstance.log("Connected to Host!", "log-success");
             return;
        }

        if (!gameInstance) return;

        switch(msg.event) {
            case 'START_GAME':
                if (!this.isHost) {
                    // Initialize peer game with host's config
                    // TODO: Need to pass random seeds/powerups to ensure sync
                    // For now, we trust the host sends necessary state in updates or we sync init
                    // The simplest sync is sending the powerup locations.
                    CONFIG.players = msg.data.players;
                    CONFIG.humanCount = msg.data.humanCount;
                    setupOverlay.style.display = 'none';
                    mainContainer.classList.add('active');
                    gameInstance = new Game();
                    gameInstance.initMultiplayer(false, this.roomId, this.playerId);
                    gameInstance.powerups = msg.data.powerups; // Sync powerups
                    gameInstance.log("Connected to Host!", "log-success");
                }
                break;
            case 'TURN_UPDATE':
                gameInstance.handleRemoteTurn(msg.data);
                break;
            case 'PLAYER_JOINED':
                if (this.isHost && gameInstance) {
                     gameInstance.log("A player joined!", "log-highlight");
                } else if (!gameInstance) {
                     // Lobby update logic could go here
                     const status = document.getElementById('lobbyStatus');
                     if(status) status.innerText = `Player joined! Ready to start?`;
                }
                break;
        }
    }

    async sendSignal(event, data) {
        await fetch(`${this.serverUrl}/api/signal`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ roomId: this.roomId, event, data })
        });
    }
}

const netManager = new NetworkManager();

</script>
</body>
</html>